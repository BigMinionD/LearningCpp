# Variable Assignment
After a variable has been defined, it can be given a value in a separate statement through the "=" operator (see Example 1.4.1)
- This process is called assignment
- "=" is called the assignment operator
- By default, assignment copies the value on the right side of the assignment operator to the variable on the left side of the operator
- This is called copy assignment
- Once a variable has been given a value, that value can be printed using the "std::cout" and "<<" operators (see Example 1.4.2)
- Normal variables can only hold one value at a time
- Do not mix up the assignment operator with the equality operator "=="

# Variable Initialization
One downside of assignment is that assigning a value to a just-defined object requires two statements, one to define the variable and the other to assign the value
- The two steps can be defined by putting curly brackets next to the variable and putting a value inside them (see Example 1.4.3)
- This is called initialization and the syntax used for it is called the initializer

# Different Initialization Forms
There are five common forms of C++ initialization (see Example 1.4.4)
- Default initialization, in which there is no value assigned
- Copy initialization, with the initial value after the "=" operator
- Direct initialization, with the initial value in parenthesis
- Direct list initialization, with the initial value in curly brackets (does not allow for narrowing conversion in initial value)
- Value initialization, with there being no value in the curly brackets which leads to the value being 0
- Other forms of initialization will be covered in later lessons
- Direct list initialization is the most preferred form of initialization
- It is highly recommended to initialize variables upon creation

# Instantiation
The term Instantiation means a variable has been created and initialized (including default initialization)
- An instantiated object is sometimes called an instance
- This term most often applies to class type objects
- Occasionally applied to other types of objects as well

# Initializing Multiple Variables
Multiple variables can be defined and initialized on the same line (see Example 1.4.5)
- A common pitfall occurs when a programmer attempts to initialize multiple variables with a single operator (see Example 1.4.6)

# Unused Initialized Variables
Modern compilers will typically issue warnings if a variable is initialized but not used
- If "treat warnings as errors" is enabled, warnings will be promoted to errors and cause compilation to fail (see Example 1.4.7)
- One way to fix this error is simply to remove the definition of the variable or comment it out if it is meant to be unused
- An alternative is to simply use the variable somewhere

# The "[[maybe_unused]]" Attribute (C++17)
There are some cases in which neither case is desireable (see Example 1.4.8)
- In the above example, the variable "gravity" is unused
- If the values are used a lot, these variables are probably copy/pasted/imported all together from the same place
- In programs where not all of the variables are used, the compiler will most likely complain about the unused variable(s)
- I could easily just remove the unused variable since there are only three
- In programs with 20, 30, or more variables, it would most likely be tedious to find each unused variable and remove/comment them out, especially if a use is found for them later
- An easy solution is to used the "[[maybe_unused]]" attribute, which tells the compiler that I'm okay with a variable being unused
- This means the compiler will no longer issue warnings for those unused variables (see Example 1.4.9)
- The compiler could also optimize the variables out of the program, meaning they have no performance impact
- [[maybe_unused]] should only be used for variables that have a legitimate reason for being unused
